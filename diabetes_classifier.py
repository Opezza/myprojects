# -*- coding: utf-8 -*-
"""diabetes_classifier.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1huC3EvEOxMYaoGkbVPKFm9zMuJtgQByx
"""

# This program uses machine learning methods for classification.
# Three methods have been applied: SVM (Support Vector Machine), KNN (K-Nearest Neighbors), and decision trees.
# diabetes dataset: https://github.com/plotly/datasets/blob/master/diabetes.csv
# originally made in Google Colaboratory

import sklearn
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.datasets import load_diabetes
from sklearn.tree import DecisionTreeClassifier
from sklearn.neighbors import KNeighborsClassifier
from sklearn.svm import SVC
from sklearn.model_selection import train_test_split
from sklearn import metrics
from sklearn.metrics import accuracy_score
from sklearn.preprocessing import StandardScaler
from sklearn.model_selection import GridSearchCV

# Reading diabetes dataset
diabetes=pd.read_csv("diabetes.csv")
diabetes

# CHecking missing values
cols_missing = [col for col in diabetes.columns
                     if diabetes[col].isnull().any()]
for i in cols_missing:
    print(i,sum(diabetes[i].isnull()))

# Basic statistics
diabetes.describe()

# Creating histograms for each column
histogram = diabetes.hist(figsize = (20,20), rwidth=0.9,color='skyblue')

# Creating a copy
diabetes_copy = diabetes.copy()

# Replacing missing values with null
cols = ['Glucose', 'BloodPressure', 'SkinThickness', 'Insulin', 'BMI']
diabetes_copy[cols] = diabetes_copy[cols].replace({0 : np.nan})

# Checking missing values
cols_missing = [col for col in diabetes_copy.columns
                     if diabetes_copy[col].isnull().any()]
for i in cols_missing:
    print(i,sum(diabetes_copy[i].isnull()))

# Basic statistics for the new dataset
diabetes_copy.describe()

# Replacing null values with mean and median
diabetes_copy['Glucose'].fillna(diabetes_copy['Glucose'].mean(), inplace = True)
diabetes_copy['BloodPressure'].fillna(diabetes_copy['BloodPressure'].mean(), inplace = True)
diabetes_copy['SkinThickness'].fillna(diabetes_copy['SkinThickness'].median(), inplace = True)
diabetes_copy['Insulin'].fillna(diabetes_copy['Insulin'].median(), inplace = True)
diabetes_copy['BMI'].fillna(diabetes_copy['BMI'].median(), inplace = True)

# Histogams
p = diabetes_copy.hist(figsize = (20,20), rwidth=0.9,color='skyblue')

# Checking missing values (just to be sure there are not any)
cols_missing = [col for col in diabetes_copy.columns
                     if diabetes_copy[col].isnull().any()]
for i in cols_missing:
    print(i,sum(diabetes_copy[i].isnull()))

# Splitting data
X = diabetes_copy.drop("Outcome",axis=1)
y= diabetes_copy["Outcome"]

# Splitting data
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

print('X_train: ', np.shape(X_train))
print('y_train: ', np.shape(y_train))
print('X_test: ', np.shape(X_test))
print('y_test: ', np.shape(y_test))

# Data scaling
scaler = StandardScaler()

X_train = scaler.fit_transform(X_train)
X_test = scaler.fit_transform(X_test)

# Utworzenie klasyfikatora SVM
svm = SVC(kernel='linear', C=1, gamma='auto')

# Fit the classifier
svm.fit(X_train, y_train)

# Predicting the label of a test sample
y_pred_svm = svm.predict(X_test)

# Model accuracy
score = accuracy_score(y_test, y_pred_svm)

print("Dokładność klasyfikacji:", score)

param_grid = {'C': [0.1, 1, 10, 100],
              'gamma': [0.1, 1, 10, 100, 'auto'],
              'kernel': ['sigmoid', 'rbf']}

# SVM
model = SVC()

# Using grid_search to find the best parameters
grid_search = GridSearchCV(model, param_grid=param_grid, cv=5)
grid_search.fit(X_train, y_train)

# Printing the parameters and model score
print("Najlepsze parametry: ", grid_search.best_params_)
print("Dokładność klasyfikacji:", grid_search.best_score_)

# Decision Tree
model_dt = DecisionTreeClassifier(random_state=0, max_depth=3)
model_dt.fit(X_train, y_train)

# Model accuracy
y_pred_dt = model_dt.predict(X_test)
accuracy_dt = accuracy_score(y_test, y_pred_dt)
print("Dokładność klasyfikacji:", accuracy_dt)

# KNN
knn = KNeighborsClassifier(n_neighbors=3)
knn.fit(X_train, y_train)


y_pred_knn = knn.predict(X_test)

# Calculating the mean accuracy for the test data
score_knn = knn.score(X_test, y_test)
print("Dokładność klasyfikacji:", score_knn)